{-|
Module      : Substitution.Pattern
Description : represent a matching pattern
Copyrigh    : (c) Guillaume Dupont, 2021
License     : GPLv3
Maintainer  : guillaume.dupont55@gmail.com

This module mainly defines patterns, which are basically generic
regular expressions (Kleene algebras). A pattern is either empty,
a repetition of a pattern, an optional of the pattern, the
alternative of two patterns or the sequence of two patterns.

The base building block of a pattern is a "label", which are left
type generic so that patterns may be used with any kind of element.

Also, we allow capturing pattern (useful for richer templates).
-}
module Substitution.Pattern (
        Pattern(..),
        normalize,
        derive,
        countCaptures
    ) where

import Substitution.Label
import Substitution.Automaton
import Substitution.Automaton.Builder

-- | A pattern of labels of type `l`
data Pattern l =
      EmptyPattern                          -- ^ The empty pattern
    | Capture  (Pattern l)                  -- ^ Capture of the given pattern (same matching)
    | Repeat   (Pattern l)                  -- ^ 0 or more occurence of the pattern (Kleene star)
    | Optional (Pattern l)                  -- ^ 0 or one occurence of the pattern
    | Or       (Pattern l) (Pattern l)      -- ^ Occurence of either one or the other of the pattern
    | Seq      (Pattern l) (Pattern l)      -- ^ Sequence of patterns (match the first then match the second)
    | Lab       l                           -- ^ One label
    deriving Show

-- | Pretty print the pattern (mostly for debug purposes)
prettyPrint :: Show l => Pattern l -> String
prettyPrint EmptyPattern = ""
prettyPrint (Capture p) = "\\(" ++ prettyPrint p ++ "\\)"
prettyPrint (Repeat p) = prettyPrint p ++ "\\*"
prettyPrint (Optional p) = prettyPrint p ++ "\\?"
prettyPrint (Or p1 p2) = prettyPrint p1 ++ "\\|" ++ prettyPrint p2
prettyPrint (Seq p1 p2) = prettyPrint p1 ++ prettyPrint p2
prettyPrint (Lab l) = show l

-- | Count the number of capture groups that are present in the
-- pattern.
-- Note that, in theory, there should be the name number of capture
-- groups in each branches of an `Or`. Without that, what every number
-- references is uncertain.
--
-- E.g. : `(a(b)c | d(e)(f))(g)` => `$3` either contains `f` or `g` depending
-- on if `abc` or `def` has been matched.
countCaptures :: Pattern l -> Int
countCaptures (Capture p)  = 1 + countCaptures p
countCaptures (Repeat p)   = countCaptures p
countCaptures (Optional p) = countCaptures p
countCaptures (Or p1 p2)   = min (countCaptures p1) (countCaptures p2)
countCaptures (Seq p1 p2)  = countCaptures p1 + countCaptures p2
countCaptures x = 0

-- | Reduce and normalize a pattern as much as possible.
-- Honestly this funciton is optionnal; but on large patterns it may
-- reduce the size of the resulting automaton.
--
-- Also, the pattern generated by parsing is often a bit messy... So this
-- cleans it up a bit.
normalize :: Pattern l -> Pattern l
normalize (Capture pt) =
    case normalize pt of
      Capture pt' -> Capture pt'
      npt         -> Capture npt
normalize (Repeat pt) =
    case normalize pt of
      EmptyPattern -> EmptyPattern
      Capture pt'  -> Capture (Repeat pt')
      Optional pt' -> Repeat pt'
      Repeat pt'   -> Repeat pt'
      npt          -> Repeat npt
normalize (Optional pt) =
    case normalize pt of
      EmptyPattern -> EmptyPattern
      Repeat pt'   -> Repeat pt'
      Optional pt' -> Optional pt'
      Capture pt'  -> Capture (Optional pt')
      npt          -> Optional npt
normalize (Or pt1 pt2) =
    case (normalize pt1, normalize pt2) of
      (EmptyPattern, EmptyPattern) -> EmptyPattern
      (npt1        , npt2        ) -> Or npt1 npt2
normalize (Seq pt1 pt2) =
    case (normalize pt1, normalize pt2) of
      (EmptyPattern, npt2        ) -> npt2
      (npt1        , EmptyPattern) -> npt1
      (npt1        , npt2        ) -> Seq npt1 npt2
normalize x = x

-- | Transform the given pattern into an automaton.
-- We use the automaton builder facility (@Substitution.Automaton.Builder@) to
-- make it easier. This also allows to wrap it in a monad, which can be useful
-- when including this deriviation in a larger context.
derive :: Monad m => Pattern l -> m (Automaton l)
derive patt =
    build $ do
        theInit <- newPlace
        setInitState theInit
        end <- deriveB theInit patt
        setValidating end
    where deriveB begin EmptyPattern = return begin
          deriveB begin (Capture patt) = do
              begin' <- newPlace
              end <- deriveB begin' patt
              end' <- newPlace
              newEdge begin BeginCapture begin'
              newEdge end   EndCapture   end'
              return end'
          deriveB begin (Repeat patt) = do
              end <- deriveB begin patt
              newEdge end Skip begin
              return begin
          deriveB begin (Optional patt) = do
              end <- deriveB begin patt
              newEdge begin Skip end
              return end
          deriveB begin (Or p1 p2) = do
              end1 <- deriveB begin p1
              end2 <- deriveB begin p2
              end <- newPlace
              newEdge end1 Skip end
              newEdge end2 Skip end
              return end
          deriveB begin (Seq p1 p2) = do
              end1 <- deriveB begin p1
              end2 <- deriveB end1 p2
              return end2
          deriveB begin (Lab l) = do
              end <- newPlace
              newEdge' begin l end
              return end




